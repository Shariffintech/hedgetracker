use leptos::prelude::*;
use leptos::widget::{button, input, text, widget};
use leptos::widget::text::{TextAlignment, TextConfig};

#[derive(Debug, Clone, PartialEq)]
struct StartupMetrics {
    initial_revenue: f64,
    customer_growth_rate: f64,
    revenue_growth_rate: f64,
}

#[derive(Default, Debug, Clone)]
struct AppState {
    metrics: StartupMetrics,
    projected_revenue: f64,
}

// fn main() {
//     let initial_state = AppState::default();
//     let gui = build_gui();
//     let window = Window::new("Startup Scenario Modeler")
//         .with_content(gui)
//         .center();

//     App::new(initial_state)
//         .update(update)
//         .render(render)
//         .build(window)
//         .run();
// }

fn build_gui() -> impl Widget<AppState> {
    let initial_revenue = input()
        .with_text("Initial Revenue:")
        .with_value("10000")
        .parse_value(f64::from_str)
        .map(|x| move |mut state: AppState| {
            state.metrics.initial_revenue = x;
            state
        });

    let customer_growth_rate = input()
        .with_text("Customer Growth Rate (per month):")
        .with_value("5")
        .parse_value(f64::from_str)
        .map(|x| move |mut state: AppState| {
            state.metrics.customer_growth_rate = x;
            state
        });

    let revenue_growth_rate = input()
        .with_text("Revenue Growth Rate (per month):")
        .with_value("10")
        .parse_value(f64::from_str)
        .map(|x| move |mut state: AppState| {
            state.metrics.revenue_growth_rate = x;
            state
        });

    let calculate_button = button()
        .with_text("Calculate")
        .on_click(|mut state: AppState| {
            state.projected_revenue = calculate_projected_revenue(&state.metrics);
            state
        });

    let revenue_text = text()
        .with_text("Projected Monthly Revenue:")
        .with_text_config(TextConfig::new().with_alignment(TextAlignment::Center))
        .with_value(|state: &AppState| format!("${:.2}", state.projected_revenue));

    widget! {
        (gui_grid
            (initial_revenue row: 0 col: 0)
            (customer_growth_rate row: 1 col: 0)
            (revenue_growth_rate row: 2 col: 0)
            (calculate_button row: 3 col: 0)
            (revenue_text row: 4 col: 0))
    }
}

fn update(msg: lept::Message, state: &mut AppState) {
    match msg {
        _ => {}
    }
}

fn render(state: &AppState) -> Element {
    widget! {()}

    // We're returning an empty widget here, as we're not actually rendering anything in the window.
    // Instead, the content is generated by the `build_gui()` function and passed to the `Window`
    // constructor in the `main()` function.
}

fn calculate_projected_revenue(metrics: &StartupMetrics) -> f64 {
    let mut revenue = metrics.initial_revenue;
    let mut customers = 1.0;

    for _ in 0..12 {
        customers *= (1.0 + metrics.customer_growth_rate / 100.0);
        revenue *= (1.0 + metrics.revenue_growth_rate / 100.0);
    }

    revenue

}

fn deploy_contract(web3: web3::Web3) -> web3::Result<web3::types::Address> {
    let contract = Contract::from_json(
        web3.clone(),
        "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419".parse().unwrap(),
        "startup_scenario_modeler.wasm".parse().unwrap(),
    )?;
}